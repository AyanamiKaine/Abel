<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Abel.Core</name>
    </assembly>
    <members>
        <member name="M:Abel.Core.AbelRunner.Run">
            <summary>
            Running a project, by default we are expecting a main.cpp file to exist
            next to the project.json file. (We should validate this)
            </summary>
        </member>
        <member name="M:Abel.Core.AbelRunner.Build">
            <summary>
            Building a project
            </summary>
        </member>
        <member name="M:Abel.Core.AbelRunner.Test">
            <summary>
            Running tests
            </summary>
        </member>
        <member name="M:Abel.Core.AbelRunner.Add">
            <summary>
            Adding a new dependency to a project.
            </summary>
        </member>
        <member name="M:Abel.Core.AbelRunner.ParseFolder(System.String)">
            <summary>
            We are parsing the root project in a folder and adding it to the project list.
            </summary>
        </member>
        <member name="M:Abel.Core.AbelRunner.ValidateProjectFiles(System.String,Abel.Core.ProjectConfig)">
            <summary>
            Checks that files referenced in the ProjectConfig actually exist on disk.
            Missing test files are stripped out and the user is warned via console.
            Returns a new config safe to pass to CmakeBuilder.
            </summary>
        </member>
        <member name="M:Abel.Core.AbelRunner.FormatElapsed(System.TimeSpan)">
            <summary>
            Formats a TimeSpan into a human-friendly string.
            Under 1s: "123ms", under 1min: "4.56s", otherwise: "1m 23s".
            </summary>
        </member>
        <member name="T:Abel.Core.CmakeBuilder">
             <summary>
             Fluent builder for generating CMakeLists.txt files.
            
             CMake has two eras: "old CMake" used global variables (include_directories, link_directories)
             that polluted everything. "Modern CMake" (3.0+) is target-based — you create a target
             (executable or library) and attach properties directly to it. Properties have visibility:
            
               PRIVATE   — only this target uses it (implementation detail)
               PUBLIC    — this target AND anyone who links to it gets it (part of your API)
               INTERFACE — only consumers get it, not the target itself (header-only libs)
            
             This builder only generates modern, target-based CMake. Every source file, compile flag,
             and dependency is scoped to a specific target with explicit visibility.
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.SetMinimumVersion(System.String)">
             <summary>
             Emits: cmake_minimum_required(VERSION x.xx)
            
             This must be the first line in any CMakeLists.txt. It tells CMake the oldest version
             that can build this project. CMake uses this to enable/disable "policies" — behavioral
             changes between versions. Setting 3.28 means we opt into all modern behaviors up to 3.28,
             including native C++20 module support (FILE_SET CXX_MODULES) which landed in 3.28.
            
             Default: "3.28" — the minimum for C++ module support.
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.SetProject(System.String,System.String)">
             <summary>
             Emits: project(name LANGUAGES CXX)
            
             Declares the project name and which compilers CMake needs to find. "LANGUAGES CXX" means
             we only need a C++ compiler. If you also have .c files, use "C CXX". The project name
             becomes available as the ${PROJECT_NAME} variable and is used in IDE project files.
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.SetCxxStandard(System.Int32)">
             <summary>
             Emits: set(CMAKE_CXX_STANDARD 23), CMAKE_CXX_STANDARD_REQUIRED ON, CMAKE_CXX_EXTENSIONS OFF
            
             Controls which C++ standard the compiler targets. STANDARD_REQUIRED ON means CMake will
             error if the compiler doesn't support this standard (instead of silently falling back).
             EXTENSIONS OFF disables compiler-specific extensions (like GNU's __attribute__), keeping
             your code portable across compilers. For libraries, we also emit target_compile_features()
             with PUBLIC visibility so consumers automatically inherit the minimum standard requirement.
            
             Default: 23 (C++23).
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.SetOutputType(Abel.Core.OutputType)">
             <summary>
             Controls whether we emit add_executable() or add_library(... STATIC).
            
             Executables are standalone programs with a main(). Libraries are compiled code meant to
             be linked into other targets. STATIC means the .a/.lib is baked directly into the consumer
             at link time (as opposed to SHARED/.so/.dll which is loaded at runtime). Abel defaults to
             STATIC because it avoids the headache of runtime library paths, and the linker strips
             unused code anyway.
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.AddPrivateSources(System.String[])">
             <summary>
             Emits: target_sources(name PRIVATE file1.cpp file2.cpp ...)
            
             PRIVATE sources are implementation files (.cpp, .cc) that only this target compiles.
             Other targets that link to this library will NOT see or compile these files — they're
             internal. This is the correct scope for .cpp files because consumers only need your
             public headers or module interfaces, not your implementation.
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.AddModuleSources(System.String[])">
             <summary>
             Emits: target_sources(name PUBLIC FILE_SET CXX_MODULES FILES math.cppm ...)
            
             C++20 modules replace the old #include model. A .cppm file declares "export module X;"
             and consumers do "import X;" instead of #include. CMake 3.28 added FILE_SET CXX_MODULES
             to handle the new compilation model — the compiler needs to build module interfaces in
             dependency order before anything that imports them. PUBLIC visibility means consumers
             of this library can also import these modules (which is the whole point of exporting them).
            
             Note: only Clang 16+, MSVC 17.4+, and GCC 14+ support this. CMake + Ninja is the most
             reliable generator combo for modules as of 2024.
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.AddPublicHeaders(System.String[])">
             <summary>
             Emits: target_sources(name PUBLIC FILE_SET HEADERS FILES math.h ...)
            
             For traditional (non-module) libraries, public headers are the .h/.hpp files that
             consumers #include. FILE_SET HEADERS (CMake 3.23+) is the modern way to declare them —
             it replaces the old target_include_directories() dance and ensures headers get installed
             to the right location automatically. PUBLIC means both this target and its consumers
             can see these headers during compilation.
            
             You don't need this if you're using C++20 modules exclusively (use AddModuleSources).
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.AddFindPackage(System.String,System.Boolean,System.Boolean)">
             <summary>
             Emits: find_package(name [CONFIG] [REQUIRED])
            
             find_package() searches for a library that's already installed on the system. When it
             succeeds, it makes a CMake target available (typically name::name) that you can link to.
            
             CONFIG mode means CMake looks for a name-config.cmake file that the library installed —
             this is the preferred modern approach because the library author defined exactly how to
             consume it. The fallback "Module" mode uses CMake's built-in FindXxx.cmake scripts, which
             are less reliable and often outdated.
            
             REQUIRED means CMake errors immediately if the package isn't found, instead of continuing
             and failing later with a cryptic linker error.
            
             After find_package(), you still need to call AddLinkLibrary() to actually link the target.
             </summary>
             <param name="packageName">The package name CMake searches for (case-sensitive on Linux).</param>
             <param name="required">If true, CMake aborts when the package isn't found.</param>
             <param name="configMode">If true, only look for name-config.cmake files (skip FindXxx.cmake).</param>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.AddFetchContent(System.String,System.String,System.String)">
             <summary>
             Emits: FetchContent_Declare(name GIT_REPOSITORY ... GIT_TAG ...) + FetchContent_MakeAvailable(name)
            
             FetchContent (CMake 3.11+) downloads a dependency's source code at configure time and
             builds it as part of your project. This is the modern alternative to git submodules or
             ExternalProject. The key advantage: the downloaded targets become first-class citizens
             in your build — you can link to them immediately with target_link_libraries().
            
             GIT_TAG should be a specific release tag (e.g. "v2.4.12") or commit hash, never a branch
             name, because branches move and your build would become non-reproducible.
            
             Tradeoff: this re-downloads and rebuilds from source every time you delete your build dir.
             For large deps, a system-level install via find_package() is faster for iteration.
             Abel uses FetchContent for small deps like doctest where build time is negligible.
             </summary>
             <param name="name">Logical name for CMake (used as the FetchContent identifier).</param>
             <param name="gitRepo">HTTPS URL of the git repository.</param>
             <param name="gitTag">Exact tag or commit hash to pin to.</param>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.AddCmakeOption(System.String,System.String)">
             <summary>
             Emits: set(KEY VALUE CACHE BOOL "")
            
             Sets a CMake cache variable BEFORE FetchContent processes dependencies.
             This is how Abel controls third-party dependency build options
             (for example: SDL_SHARED OFF for static SDL builds).
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.AddLinkLibrary(System.String)">
             <summary>
             Emits: target_link_libraries(name PRIVATE|PUBLIC dep1 dep2 ...)
            
             This is the single most important command in modern CMake. Linking a target does NOT just
             add -l flags to the linker — it transitively propagates all PUBLIC properties from the
             dependency: include paths, compile definitions, compile features, and further transitive
             dependencies. This is why modern CMake "just works" compared to manually wiring
             include_directories() and link_directories().
            
             Always use the namespaced target name (e.g. "math_module::math_module") rather than a raw
             library filename. Namespaced targets cause a clear CMake error if missing, while a raw
             name silently becomes a linker flag -lmath_module which produces a cryptic link error.
            
             Visibility is set automatically: PRIVATE for executables (nothing links to an exe),
             PUBLIC for libraries (consumers need to see transitive dependencies).
             </summary>
             <param name="target">The CMake target to link, e.g. "math_module::math_module".</param>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.AddTest(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
             <summary>
             Emits: include(CTest) + add_executable(testName ...) + add_test(NAME testName COMMAND testName)
             wrapped inside if(BUILD_TESTING) ... endif()
            
             CTest is CMake's built-in test runner. include(CTest) creates a BUILD_TESTING option
             (defaults ON) that lets users disable tests with -DBUILD_TESTING=OFF. Each test is a
             separate executable that returns 0 for pass, non-zero for fail. After building, you
             run them with "ctest --test-dir build" or "cmake --build build --target test".
            
             The test executable is linked PRIVATE to the main library target (so it can test it)
             plus any test framework targets like doctest::doctest.
            
             The if(BUILD_TESTING) guard means test dependencies (like doctest) are only downloaded
             and built when someone actually wants to run tests — consumers of your library skip them.
             </summary>
             <param name="testName">Name of the test executable and CTest test entry.</param>
             <param name="sources">Source files for the test executable.</param>
             <param name="linkLibraries">Additional libraries to link (e.g. test frameworks). The main project target is linked automatically.</param>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.EnableInstall">
             <summary>
             Emits: install(TARGETS ...) + install(EXPORT ...) + config file generation.
            
             "Installing" in CMake means copying your built artifacts (libraries, headers, module files)
             to a system-wide or prefix-local directory so OTHER projects can find them via find_package().
            
             This generates three things:
               1. install(TARGETS) — copies the .a/.so and headers/modules to standard directories
                  using GNUInstallDirs (lib/, include/, etc.)
               2. install(EXPORT) — creates a name-targets.cmake file that re-creates the CMake target
                  with all its properties, namespaced as name::name.
               3. A name-config.cmake file — the entry point that find_package() looks for. It includes
                  the targets file so consumers get a ready-to-use target.
            
             After "cmake --install build", another project can do:
               find_package(math_module CONFIG REQUIRED)
               target_link_libraries(my_app PRIVATE math_module::math_module)
             and everything (includes, link flags, transitive deps) propagates automatically.
            
             Only meaningful for library targets — executables don't get consumed by other builds.
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.FromProjectConfig(Abel.Core.ProjectConfig,Abel.Core.PackageRegistry)">
             <summary>
             Creates a pre-configured builder from a project.json config.
            
             Mapping:
               config.Name             → project() name and target name
               config.CXXStandard      → CMAKE_CXX_STANDARD + target_compile_features
               config.ProjectOutputType → add_executable() vs add_library(STATIC)
               config.Sources["modules"]  → FILE_SET CXX_MODULES (C++20 module interfaces)
               config.Sources["private"]  → PRIVATE sources (implementation .cpp files)
               config.Sources["public"]   → FILE_SET HEADERS (traditional .h/.hpp)
               config.Dependencies      → find_package(dep CONFIG REQUIRED) + target_link_libraries(dep::dep)
               config.Tests.Files       → CTest executables, auto-fetches doctest via FetchContent
            
             Libraries automatically get install/export rules so they can be consumed
             by other Abel projects via find_package() after "cmake --install build".
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.WritePreamble(Abel.Core.CmakeWriter)">
            <summary>
            The preamble sets global project defaults. CMAKE_CXX_STANDARD as a variable is a fallback
            for targets that don't explicitly set compile features — it's the "floor" standard.
            CMAKE_CXX_EXTENSIONS OFF avoids GNU extensions (-std=gnu++23 → -std=c++23) for portability.
            </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.WriteFetchContent(Abel.Core.CmakeWriter)">
            <summary>
            FetchContent is declared first (before find_package) because fetched deps may provide
            targets that find_package would otherwise fail to locate. FetchContent_MakeAvailable()
            calls FetchContent_Populate() + add_subdirectory() internally, making all targets from
            the fetched project available immediately.
            </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.WriteCompileFeatures(Abel.Core.CmakeWriter)">
            <summary>
            target_compile_features() is the modern way to express "this target requires C++23".
            Unlike the CMAKE_CXX_STANDARD variable, this propagates through target_link_libraries:
            if library A requires C++23 and executable B links to A, B automatically compiles with
            at least C++23. We set PUBLIC for libraries so this propagation happens, and skip it
            for executables since nothing links to them.
            </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.WriteLinkLibraries(Abel.Core.CmakeWriter)">
            <summary>
            For executables: PRIVATE because nothing further links to an exe.
            For libraries: PUBLIC because if library A depends on library B, then anything
            linking to A also needs B's symbols and include paths transitively.
            </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.WriteInstallRules(Abel.Core.CmakeWriter)">
             <summary>
             Install rules use GNUInstallDirs for cross-platform directory conventions:
               ${CMAKE_INSTALL_LIBDIR}     → lib/ or lib64/ depending on distro
               ${CMAKE_INSTALL_INCLUDEDIR} → include/
            
             The export chain works like this:
               install(TARGETS ... EXPORT name-targets) — tells CMake to record this target's properties
               install(EXPORT name-targets)             — writes name-targets.cmake that recreates the target
               name-config.cmake                        — entry point file that find_package() searches for
            
             The config file uses CMakeFindDependencyMacro so that transitive find_package() calls
             happen automatically when a consumer does find_package(name).
             </summary>
        </member>
        <member name="M:Abel.Core.CmakeBuilder.WriteTests(Abel.Core.CmakeWriter)">
            <summary>
            Tests are guarded by if(BUILD_TESTING) so that consumers who add this project
            via FetchContent or add_subdirectory don't waste time building and linking tests
            they'll never run. Users opt out with: cmake -DBUILD_TESTING=OFF
            </summary>
        </member>
        <member name="T:Abel.Core.CmakeWriter">
            <summary>
            Tiny helper that builds up the CMake script line-by-line,
            keeping indentation and blank-line logic in one place.
            </summary>
        </member>
        <member name="T:Abel.Core.DependencySpec">
            <summary>
            Dependency spec parsed from project.json entries:
              "sdl3" -> PackageName=sdl3, VariantName=null
              "imgui/sdl3_renderer" -> PackageName=imgui, VariantName=sdl3_renderer
            </summary>
        </member>
        <member name="M:Abel.Core.DependencySpec.#ctor(System.String,System.String)">
            <summary>
            Dependency spec parsed from project.json entries:
              "sdl3" -> PackageName=sdl3, VariantName=null
              "imgui/sdl3_renderer" -> PackageName=imgui, VariantName=sdl3_renderer
            </summary>
        </member>
        <member name="T:Abel.Core.PackageEntry">
            <summary>
            Describes a curated third-party package Abel can fetch via CMake FetchContent.
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.Name">
            <summary>
            Registry key users write in project.json, e.g. "sdl3" or "fmt".
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.GitRepository">
            <summary>
            HTTPS git URL used by FetchContent_Declare(GIT_REPOSITORY ...).
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.GitTag">
            <summary>
            Pinned git tag or commit hash used by FetchContent_Declare(GIT_TAG ...).
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.CmakeTargets">
            <summary>
            CMake target names to link, e.g. "SDL3::SDL3".
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.CmakeOptions">
            <summary>
            CMake cache options set before FetchContent_MakeAvailable, e.g. SDL_SHARED=OFF.
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.Dependencies">
            <summary>
            Registry dependency names to resolve transitively.
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.Strategy">
            <summary>
            Strategy Abel uses to consume this dependency.
              fetchcontent  normal FetchContent_MakeAvailable
              wrapper       FetchContent_Populate + Abel-generated CMake target
              header_inject FetchContent_Populate + INTERFACE include target
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.Sources">
            <summary>
            For wrapper/header_inject: source files relative to fetched source root.
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.IncludeDirs">
            <summary>
            Include directories relative to fetched source root.
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.CompileDefinitions">
            <summary>
            Compile definitions applied to generated wrapper targets.
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.Variants">
            <summary>
            Optional variants, keyed by variant name (e.g. sdl3_renderer).
            </summary>
        </member>
        <member name="P:Abel.Core.PackageEntry.Description">
            <summary>
            Optional human-readable summary for list/search UIs.
            </summary>
        </member>
        <member name="T:Abel.Core.PackageVariant">
            <summary>
            Optional package variant (backend/profile) extending a base package.
            </summary>
        </member>
        <member name="T:Abel.Core.PackageRegistry">
            <summary>
            Curated third-party package registry used for dependency resolution.
            </summary>
        </member>
        <member name="T:Abel.Core.ToolChecker">
            <summary>
            Checks that required build tools (C++ compiler, CMake, Ninja) are installed
            and reachable on PATH. Prints warnings for anything missing but never aborts —
            the build might still work if tools are in non-standard locations.
            </summary>
        </member>
        <member name="M:Abel.Core.ToolChecker.CheckAll(System.Boolean)">
            <summary>
            Runs all checks and prints a summary. Returns true if everything looks good.
            </summary>
        </member>
        <member name="M:Abel.Core.ToolChecker.ProbeCompilers">
            <summary>
            Probes the OS-appropriate set of C++ compilers.
            On Windows: clang++, cl (MSVC). On Linux/macOS: g++, clang++.
            Only one needs to be present — the user picks via CMake toolchain or defaults.
            </summary>
        </member>
        <member name="M:Abel.Core.ToolChecker.Probe(System.String,System.String,System.Func{System.String,System.String})">
            <summary>
            Tries to run an executable with the given arguments and extract a version string.
            Returns Found=false if the process fails to start or returns non-zero.
            </summary>
        </member>
        <member name="M:Abel.Core.ToolChecker.ProbeMsvc">
            <summary>
            MSVC's cl.exe is special — it's not typically on PATH. It lives inside the
            Visual Studio installation and requires vcvarsall.bat to set up the environment.
            We check if vswhere.exe can find a VS install with the C++ workload.
            </summary>
        </member>
        <member name="M:Abel.Core.ToolChecker.WhichAsync(System.String)">
            <summary>
            Resolves the full path of an executable using 'where' (Windows) or 'which' (Unix).
            </summary>
        </member>
    </members>
</doc>
