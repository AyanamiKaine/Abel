name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  actions: read

jobs:
  publish-nuget:
    name: Publish NuGet Tool
    runs-on: ubuntu-latest
    environment: NUGET

    env:
      DOTNET_NOLOGO: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true
      NUGET_PACKAGES: ${{ github.workspace }}/.nuget/packages

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"

      - name: Validate NuGet secret availability
        shell: bash
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
          NUGET_KEY: ${{ secrets.NUGET_KEY }}
        run: |
          if [ -n "$NUGET_API_KEY" ]; then
            echo "NuGet secret detected: NUGET_API_KEY"
            exit 0
          fi

          if [ -n "$NUGET_KEY" ]; then
            echo "::warning::Using fallback secret name NUGET_KEY. Prefer NUGET_API_KEY."
            exit 0
          fi

          echo "::error::No NuGet secret available."
          echo "::error::Add repository secret 'NUGET_API_KEY' (recommended) or 'NUGET_KEY'."
          echo "::error::If you added the secret recently, re-run the workflow."
          exit 1

      - name: Wait for successful CI for this commit
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.sha;
            const isTagRef = (context.ref ?? "").startsWith("refs/tags/");
            const expectedBranch = context.payload.repository?.default_branch ?? "main";
            const pollIntervalMs = 20 * 1000;
            const timeoutMs = 60 * 60 * 1000;
            const deadline = Date.now() + timeoutMs;

            if (!isTagRef) {
              core.setFailed("Release publish requires a tag ref (for example: refs/tags/v1.2.3).");
              return;
            }

            while (true) {
              const response = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: "ci.yml",
                head_sha: sha,
                per_page: 50,
              });

              const matchingRuns = response.data.workflow_runs
                .filter(run => run.event === "push" && run.head_branch === expectedBranch)
                .sort((a, b) => {
                  const aTime = new Date(a.created_at).getTime();
                  const bTime = new Date(b.created_at).getTime();
                  return bTime - aTime;
                });

              if (matchingRuns.length > 0) {
                const run = matchingRuns[0];
                core.notice(
                  `CI run #${run.run_number} (${run.html_url}) status=${run.status}, conclusion=${run.conclusion ?? "n/a"}.`
                );

                if (run.status === "completed") {
                  if (run.conclusion === "success") {
                    core.notice(
                      `Using successful CI run #${run.run_number} (${run.html_url}) for commit ${sha}.`
                    );
                    return;
                  }

                  core.setFailed(
                    `CI run #${run.run_number} (${run.html_url}) finished with conclusion '${run.conclusion}'. ` +
                    `Publish is blocked.`
                  );
                  return;
                }
              } else {
                core.notice(
                  `No CI run for commit ${sha} on '${expectedBranch}' yet. Waiting...`
                );
              }

              if (Date.now() >= deadline) {
                core.setFailed(
                  `Timed out waiting for a successful 'ci.yml' run for commit ${sha} on branch '${expectedBranch}'.`
                );
                return;
              }

              await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
            }

      - name: Install Linux build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake ninja-build g++

      - name: Resolve version and validate tag
        id: version
        shell: bash
        run: |
          CSPROJ_VERSION="$(grep -oPm1 '(?<=<Version>)[^<]+' Abel/Abel.csproj)"
          if [ -z "$CSPROJ_VERSION" ]; then
            echo "::error::Could not read <Version> from Abel/Abel.csproj"
            exit 1
          fi

          if [[ "${GITHUB_REF_TYPE}" != "tag" ]]; then
            echo "::error::Release workflow must run from a version tag (for example: v$CSPROJ_VERSION)."
            exit 1
          fi

          TAG_VERSION="${GITHUB_REF_NAME#v}"
          if [ "$TAG_VERSION" != "$CSPROJ_VERSION" ]; then
            echo "::error::Tag version '$TAG_VERSION' does not match csproj version '$CSPROJ_VERSION'."
            exit 1
          fi

          echo "package_version=$CSPROJ_VERSION" >> "$GITHUB_OUTPUT"

      - name: Build
        run: dotnet build Abel/Abel.csproj -c Release

      - name: Pack
        run: dotnet pack Abel/Abel.csproj -c Release -o artifacts/nupkg

      - name: Smoke test packaged tool
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.package_version }}"
          dotnet tool install Abel.Tool --tool-path ./.tools --add-source artifacts/nupkg --version "$VERSION"
          ./.tools/abel --version
          ./.tools/abel init ci_release_smoke
          ./.tools/abel add --project ./ci_release_smoke fmt
          ./.tools/abel build ./ci_release_smoke

      - name: Publish to NuGet
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
          NUGET_KEY: ${{ secrets.NUGET_KEY }}
        shell: bash
        run: |
          KEY="$NUGET_API_KEY"
          if [ -z "$KEY" ]; then
            KEY="$NUGET_KEY"
          fi

          if [ -z "$KEY" ]; then
            echo "::error::Missing NuGet secret. Expected NUGET_API_KEY (or fallback NUGET_KEY)."
            exit 1
          fi

          VERSION="${{ steps.version.outputs.package_version }}"
          PACKAGE="artifacts/nupkg/Abel.Tool.${VERSION}.nupkg"
          if [ ! -f "$PACKAGE" ]; then
            echo "::error::Package not found: $PACKAGE"
            exit 1
          fi

          dotnet nuget push "$PACKAGE" \
            --source "https://api.nuget.org/v3/index.json" \
            --api-key "$KEY" \
            --skip-duplicate
